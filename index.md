# Сортировка подсчётом

**Сортировка подсчетом** (англ.*counting sort*) - алгоритм сортировки целых чисел в диапазоне от **0** до некоторой константы **k** или сложных объектов, работающий за линейное время.

## Сортировка целых чисел
Это простейший вариант алгоритма.

## Описание
Исходная последовательность чисел длины **_n_**, а в конце отсортированная, хранится в массиве **_A_**. Также используется вспомогательный массив **_С_** с индексами от **0** до **k−1**, изначально заполняемый нулями.
 - Последовательно пройдём по массиву A и запишем в C[i] количество чисел, равных i.
 - Теперь достаточно пройти по массиву **_C_** и для каждого number_∈{0,...,k−1}_ в массив **_A_** последовательно записать число **_C[number]_** раз. 

## Псевдокод
```
function simpleCountingSort(A: int[n]): 
    for number = 0 to k - 1
        C[number] = 0 
    for i = 0 to n - 1
        C[A[i]] = C[A[i]] + 1;     
    pos = 0;
    for number = 0 to k - 1
        for i = 0 to C[number] - 1
            A[pos] = number;
            pos = pos + 1;
``` 
## Сортировка сложных объектов
Сортировка целых чисел за линейное время это хорошо, но недостаточно. Иногда бывает очень желательно применить быстрый алгоритм сортировки подсчетом для упорядочивания набора каких-либо "сложных" данных. Под "сложными объектами" здесь подразумеваются структуры, содержащие в себе несколько полей. Одно из них мы выделим и назовем ключом, сортировка будет идти именно по нему (предполагается, что значения, принимаемые ключом — целые числа в диапазоне от **_0 до k−1)_**.

Мы не сможем использовать здесь в точности тот же алгоритм, что и для сортировки подсчетом обычных целых чисел, потому что в наборе могут быть различные структуры, имеющие одинаковые ключи. Существует два способа справиться с этой проблемой — использовать списки для хранения структур в отсортированном массиве или заранее посчитать количество структур с одинаковыми ключами для каждого значения ключа.

## Описание
Исходная последовательность из **n** структур хранится в массиве **A**, а отсортированная — в массиве **B** того же размера. Кроме того, используется вспомогательный массив **P** с индексами от **_0 до k−1_**.

Идея алгоритма состоит в предварительном подсчете количества элементов с различными ключами в исходном массиве и разделении результирующего массива на части соответствующей длины (будем называть их блоками). Затем при повторном проходе исходного массива каждый его элемент копируется в специально отведенный его ключу блок, в первую свободную ячейку. Это осуществляется с помощью массива индексов **P**, в котором хранятся индексы начала блоков для различных ключей. **_P[key]_** — индекс в результирующем массиве, соответствующий первому элементу блока для ключа _key_.
  - Пройдем по исходному массиву **A** и запишем в P[i] количество структур, ключ которых равен **_i_**.
 
![image](https://user-images.githubusercontent.com/93074988/144749208-a96ae2f7-58b9-4337-8396-cdb1b3c38326.png)

  - Мысленно разобьем массив **B** на k блоков, длина каждого из которых равна соответственно P[0], P[1], ..., P[k].

![image](https://user-images.githubusercontent.com/93074988/144749237-644d0417-6deb-4b7c-b483-aa13ef9c2870.png)

  - Теперь массив **P** нам больше не нужен. Превратим его в массив, хранящий в **P[i] 
сумму элементов от 0 до i−1 старого массива P**.

![image](https://user-images.githubusercontent.com/93074988/144749337-2a3d5e5e-855f-435c-95f6-14f994fcb99d.png)

  - Теперь "сдвинем" массив **P** на элемент вперед: в новом массиве **P[0]=0, а для i>0 P[i]=Pold[i−1], где Pold — старый массив P**.
Это можно сделать за один проход по массиву P, причем одновременно с предыдущим шагом.
После этого действия в массиве P будут хранится индексы массива **B**. **P[key] указывает на начало блока в B**, соответствующего ключу _key_.

![image](https://user-images.githubusercontent.com/93074988/144749375-31825e57-feca-44ac-a575-98c36d66e428.png)

  - Произведем саму сортировку. Еще раз пройдем по исходному массиву **A** и для всех **i∈[0,n−1] будем помещать структуру A[i] в массив B на место P[A[i].key]**, а затем увеличивать **P[A[i].key] на 1**. Здесь A[i].key — это ключ структуры, находящейся в массиве A на i-том месте.

![image](https://user-images.githubusercontent.com/93074988/144749412-ab17b132-9de4-45c3-957a-2a07610110df.png)

Таким образом после завершения алгоритма в B будет содержаться исходная последовательность в отсортированном виде (так как блоки расположены по возрастанию соответствующих ключей).

Стоит также отметить, что эта сортировка является устойчивой, так как два элемента с одинаковыми ключами будут добавлены в том же порядке, в каком просматривались в исходном массиве A. Благодаря этому свойству существует _цифровая сортировка.

## Псевдокод
Здесь **A и B** — массивы структур размера **n**, с индексами от **_0 до n−1_**. **P** — целочисленный массив размера k, с индексами от **_0 до k−1_**, где k — количество различных ключей.
```
function complexCountingSort(A: **int[n], B: int[n])**:
    for i = 0 to k - 1
        P[i] = 0;         
    for i = 0 to length[A] - 1
        P[A[i].key] = P[A[i].key] + 1;     
    carry = 0;
    for i = 0 to k - 1
        temporary = P[i];
        P[i] = carry;
        carry = carry + temporary;     
    for i = 0 to length[A] - 1
        B[P[A[i].key]] = A[i];
        P[A[i].key] = P[A[i].key] + 1;
 ```
        
## Анализ
В первом алгоритме первые два цикла работают за ***Θ(k) и Θ(n)***, соответственно; двойной цикл за **Θ(n+k)**. Алгоритм имеет линейную временную трудоёмкость **Θ(n+k)**. Используемая дополнительная память равна **Θ(k)**.

Второй алгоритм состоит из двух проходов по массиву *A* размера n и одного прохода по массиву *P* размера k. Его трудоемкость, таким образом, равна ***Θ(n+k)***. На практике сортировку подсчетом имеет смысл применять, если k=O(n), поэтому можно считать время работы алгоритма равным Θ(n).
Как и в обычной сортировке подсчетом, требуется ***Θ(n+k)*** дополнительной памяти — на хранение массива B размера n и массива P размера k.

Алгоритм работает за линейное время, но является **псевдополиномиальным**.

## Источники информации
  - Сортировка подсчетом — Википедия
  - Counting sort — Wikipedia
  - Кормен Т., Лейзерсон Ч., Ривест Р. Алгоритмы: построение и анализ. — 2-е изд. — М.: Издательский дом «Вильямс», 2007. — С. 224—226.
